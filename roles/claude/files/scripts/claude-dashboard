#!/usr/bin/env bash

# Claude Dashboard - gather/scatter toggle for Claude tmux panes
# Gathers all Claude panes into a tiled monitor session, or scatters them back.

# Guard: tmux must be running
tmux info &>/dev/null || exit 1

STATUS_DIR="$HOME/.cache/claude-status"
ORIGINS_FILE="$STATUS_DIR/monitor-origins"
RETURN_FILE="$STATUS_DIR/monitor-return-session"
mkdir -p "$STATUS_DIR"

# PID tree walking detection (3 levels deep)
_check_pid_tree() {
  local pid="$1" depth="$2"
  [ "$depth" -le 0 ] && return 1
  for child in $(pgrep -P "$pid" 2>/dev/null); do
    local cmd
    cmd=$(ps -o comm= -p "$child" 2>/dev/null)
    [[ "$cmd" == "claude" || "$cmd" == "opencode" ]] && return 0
    _check_pid_tree "$child" $((depth - 1)) && return 0
  done
  return 1
}

_has_claude_in_pane() {
  local pane_pid="$1"
  _check_pid_tree "$pane_pid" 3
}

# GATHER: collect all Claude panes into a tiled monitor session
do_gather() {
  local claude_panes=()
  local pane_id pane_pid session_name window_id

  while IFS='|' read -r pane_id pane_pid session_name window_id; do
    _has_claude_in_pane "$pane_pid" || continue
    claude_panes+=("${pane_id}|${session_name}|${window_id}")
  done < <(tmux list-panes -a -F "#{pane_id}|#{pane_pid}|#{session_name}|#{window_id}")

  if [ ${#claude_panes[@]} -eq 0 ]; then
    tmux display-message "No active Claude sessions"
    exit 0
  fi

  # Save pre-gather session
  tmux display-message -p '#{session_name}' >"$RETURN_FILE"

  # Save origin map
  : >"$ORIGINS_FILE"
  for entry in "${claude_panes[@]}"; do
    echo "$entry" >>"$ORIGINS_FILE"
  done

  # Set pane titles before joining (for border labels)
  for entry in "${claude_panes[@]}"; do
    IFS='|' read -r pane_id session_name _rest <<<"$entry"
    tmux select-pane -t "$pane_id" -T "$session_name"
  done

  # Create monitor session
  tmux new-session -d -s claude-monitor

  # Join first pane
  local first_pane="${claude_panes[0]%%|*}"
  tmux join-pane -s "$first_pane" -t claude-monitor:0 2>/dev/null || true

  # Kill the empty default pane
  tmux kill-pane -t claude-monitor:0.0 2>/dev/null || true

  # Join remaining panes
  for ((i = 1; i < ${#claude_panes[@]}; i++)); do
    local p="${claude_panes[$i]%%|*}"
    tmux join-pane -h -s "$p" -t claude-monitor:0 2>/dev/null || true
  done

  # Apply tiled layout
  tmux select-layout -t claude-monitor:0 tiled

  # Enable pane border labels
  tmux set-option -w -t claude-monitor:0 pane-border-status top
  tmux set-option -w -t claude-monitor:0 pane-border-format " #[fg=#89b4fa,bold]#{pane_title}#[default] "

  # Switch client
  tmux switch-client -t claude-monitor

  # Stale status cleanup: remove status files for panes that no longer exist
  local existing_panes
  existing_panes=$(tmux list-panes -a -F '#{pane_id}' 2>/dev/null)
  for status_file in "$STATUS_DIR"/pane_*.status; do
    [ -f "$status_file" ] || continue
    local pane_num
    pane_num=$(basename "$status_file" .status)
    pane_num="${pane_num#pane_}"
    if ! echo "$existing_panes" | grep -q "^%${pane_num}$"; then
      rm -f "$status_file"
    fi
  done
}

# SCATTER: return panes from monitor session to their original locations
do_scatter() {
  if [ ! -f "$ORIGINS_FILE" ]; then
    tmux display-message "No monitor origins found"
    exit 0
  fi

  local return_session=""
  [ -f "$RETURN_FILE" ] && return_session=$(cat "$RETURN_FILE")

  # Ensure return target exists before we start dismantling monitor.
  # Recreate original sessions as needed so switch-client has somewhere to go.
  local pane_id session_name window_id
  while IFS='|' read -r pane_id session_name _rest; do
    [ -z "$session_name" ] && continue
    if ! tmux has-session -t "$session_name" 2>/dev/null; then
      tmux new-session -d -s "$session_name"
    fi
  done <"$ORIGINS_FILE"

  # Switch client AWAY from claude-monitor FIRST.
  # Moving panes out destroys the monitor window/session, which would
  # detach the client if it's still viewing claude-monitor.
  if [ -n "$return_session" ] && tmux has-session -t "$return_session" 2>/dev/null; then
    tmux switch-client -t "$return_session"
  else
    # Pick any non-monitor session
    local fallback
    fallback=$(tmux list-sessions -F '#{session_name}' | grep -v '^claude-monitor$' | head -1)
    if [ -n "$fallback" ]; then
      tmux switch-client -t "$fallback"
    fi
  fi

  # Now move panes back to their origins
  while IFS='|' read -r pane_id session_name window_id; do
    [ -z "$pane_id" ] && continue

    # Check pane still exists
    if ! tmux display-message -t "$pane_id" -p '#{pane_id}' 2>/dev/null >/dev/null; then
      continue
    fi

    # Try original window first, then session, then create session
    if tmux display-message -t "$window_id" -p '#{window_id}' 2>/dev/null >/dev/null; then
      tmux join-pane -s "$pane_id" -t "$window_id" 2>/dev/null || true
    elif tmux has-session -t "$session_name" 2>/dev/null; then
      tmux break-pane -s "$pane_id" -t "$session_name:" 2>/dev/null || true
    else
      tmux new-session -d -s "$session_name" && tmux break-pane -s "$pane_id" -t "$session_name:" 2>/dev/null || true
    fi
  done <"$ORIGINS_FILE"

  # Clean up
  rm -f "$ORIGINS_FILE" "$RETURN_FILE"

  # Kill monitor session (may already be gone if all panes were moved out)
  tmux kill-session -t claude-monitor 2>/dev/null || true
}

# Toggle logic: no flags, no fzf
current_session=$(tmux display-message -p '#{session_name}')

if [ "$current_session" = "claude-monitor" ]; then
  do_scatter
elif tmux has-session -t claude-monitor 2>/dev/null; then
  tmux switch-client -t claude-monitor
else
  do_gather
fi
